use actions as actionspec.
use predicates as knowledge.



order=linearall.
exit=always.


% Module to build student housing when we have enough budget.
module normalMod {
	
	% if we have the goal to build more studenthousing get area where we can build
	% this is a time intensive operation so the counter makes sure it doesn't happen every cycle
	if bel(refreshcounter(X), X < 0
	),
	goal(goalBuildStudentHousing) then
			get_relevant_areas(0, build, []) 
			+ delete(refreshcounter(X)) 
			+ insert(refreshcounter(50)).
		
	% Check to see if we can still build student housing on owned land, if so Build student housing.
	% Also decrement the counter to refresh the relevantarea's
	if bel(functions(FS), 
		member([Name,Id,L],FS),
		member('STUDENT',L),
		relevant_areas(0,[[MultiPolygon|Y]|Z]),
		not(Z = []),
		refreshcounter(Count),
		NewCount is Count - 1
		), goal(goalBuildStudentHousing)  
			then building_plan_construction(Id, 1, MultiPolygon)
			+ delete(refreshcounter(Count))
			+ insert(refreshcounter(NewCount))
			+ delete(relevant_areas(0,[[MultiPolygon|Y]|Z]))
			+ insert(relevant_areas(0,Z)).

	% If there is only one relevantarea left, refresh the list to see if there are any new ones available.
	if bel(relevant_areas(0,[X|Y]),
		Y = [],
		refreshcounter(Count),
		not(Count < 0))
		then get_relevant_areas(0, build, []).	
					
	
	% If we can't build more houses on our current land, buy new land
	if bel(relevant_areas(0,[]),
	getPolygon(10,10,200,20,Polygon)), 
		goal(goalBuildStudentHousing)  
			then map_buy_land(Polygon, 40000).
			
			
			

}
